<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Live-Jamming: /home/sush/Dev/livejamming/trunk/src/client/include/fmod/fmod_codec.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>/home/sush/Dev/livejamming/trunk/src/client/include/fmod/fmod_codec.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ==================================================================================================== */</span>
<a name="l00002"></a>00002 <span class="comment">/* FMOD Ex - codec development header file. Copyright (c), Firelight Technologies Pty, Ltd. 2004-2009.  */</span>
<a name="l00003"></a>00003 <span class="comment">/*                                                                                                      */</span>
<a name="l00004"></a>00004 <span class="comment">/* Use this header if you are wanting to develop your own file format plugin to use with                */</span>
<a name="l00005"></a>00005 <span class="comment">/* FMOD&#39;s codec system.  With this header you can make your own fileformat plugin that FMOD             */</span>
<a name="l00006"></a>00006 <span class="comment">/* can register and use.  See the documentation and examples on how to make a working plugin.           */</span>
<a name="l00007"></a>00007 <span class="comment">/*                                                                                                      */</span>
<a name="l00008"></a>00008 <span class="comment">/* ==================================================================================================== */</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef _FMOD_CODEC_H</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define _FMOD_CODEC_H</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> <a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a>;
<a name="l00014"></a>00014 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">FMOD_CODEC_WAVEFORMAT</a> <a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">FMOD_CODEC_WAVEFORMAT</a>;
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">/*</span>
<a name="l00017"></a>00017 <span class="comment">    Codec callbacks</span>
<a name="l00018"></a>00018 <span class="comment">*/</span> 
<a name="l00019"></a>00019 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_OPENCALLBACK)        (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, FMOD_MODE usermode, <a class="code" href="structFMOD__CREATESOUNDEXINFO.html">FMOD_CREATESOUNDEXINFO</a> *userexinfo);
<a name="l00020"></a>00020 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_CLOSECALLBACK)       (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state);
<a name="l00021"></a>00021 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_READCALLBACK)        (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">void</span> *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizebytes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytesread);
<a name="l00022"></a>00022 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_GETLENGTHCALLBACK)   (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *length, FMOD_TIMEUNIT lengthtype);
<a name="l00023"></a>00023 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_SETPOSITIONCALLBACK) (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">int</span> subsound, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> position, FMOD_TIMEUNIT postype);
<a name="l00024"></a>00024 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_GETPOSITIONCALLBACK) (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *position, FMOD_TIMEUNIT postype);
<a name="l00025"></a>00025 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_SOUNDCREATECALLBACK) (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">int</span> subsound, FMOD_SOUND *sound);
<a name="l00026"></a>00026 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_METADATACALLBACK)    (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, FMOD_TAGTYPE tagtype, <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datalen, FMOD_TAGDATATYPE datatype, <span class="keywordtype">int</span> unique);
<a name="l00027"></a>00027 <span class="keyword">typedef</span> FMOD_RESULT (F_CALLBACK *FMOD_CODEC_GETWAVEFORMAT)       (<a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a> *codec_state, <span class="keywordtype">int</span> index, <a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">FMOD_CODEC_WAVEFORMAT</a> *waveformat);
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/*</span>
<a name="l00031"></a>00031 <span class="comment">[STRUCTURE] </span>
<a name="l00032"></a>00032 <span class="comment">[</span>
<a name="l00033"></a>00033 <span class="comment">    [DESCRIPTION]</span>
<a name="l00034"></a>00034 <span class="comment">    When creating a codec, declare one of these and provide the relevant callbacks and name for FMOD to use when it opens and reads a file.</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">    [REMARKS]</span>
<a name="l00037"></a>00037 <span class="comment">    Members marked with [in] mean the variable can be written to.  The user can set the value.&lt;br&gt;</span>
<a name="l00038"></a>00038 <span class="comment">    Members marked with [out] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.&lt;br&gt;</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">    [PLATFORMS]</span>
<a name="l00041"></a>00041 <span class="comment">    Win32, Win64, Linux, Linux64, Macintosh, Xbox360, PlayStation 2, PlayStation Portable, PlayStation 3, Wii, Solaris, iPhone</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">    [SEE_ALSO]</span>
<a name="l00044"></a>00044 <span class="comment">    FMOD_CODEC_STATE</span>
<a name="l00045"></a>00045 <span class="comment">]</span>
<a name="l00046"></a>00046 <span class="comment">*/</span>
<a name="l00047"></a><a class="code" href="structFMOD__CODEC__DESCRIPTION.html">00047</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structFMOD__CODEC__DESCRIPTION.html">FMOD_CODEC_DESCRIPTION</a>
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049     <span class="keyword">const</span> <span class="keywordtype">char</span>                     *name;            <span class="comment">/* [in] Name of the codec. */</span>
<a name="l00050"></a>00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    version;         <span class="comment">/* [in] Plugin writer&#39;s version number. */</span>
<a name="l00051"></a>00051     <span class="keywordtype">int</span>                             defaultasstream; <span class="comment">/* [in] Tells FMOD to open the file as a stream when calling System::createSound, and not a static sample.  Should normally be 0 (FALSE), because generally the user wants to decode the file into memory when using System::createSound.   Mainly used for formats that decode for a very long time, or could use large amounts of memory when decoded.  Usually sequenced formats such as mod/s3m/xm/it/midi fall into this category.   It is mainly to stop users that don&#39;t know what they&#39;re doing from getting FMOD_ERR_MEMORY returned from createSound when they should have in fact called System::createStream or used FMOD_CREATESTREAM in System::createSound. */</span>
<a name="l00052"></a>00052     FMOD_TIMEUNIT                   timeunits;       <span class="comment">/* [in] When setposition codec is called, only these time formats will be passed to the codec. Use bitwise OR to accumulate different types. */</span>
<a name="l00053"></a>00053     FMOD_CODEC_OPENCALLBACK         open;            <span class="comment">/* [in] Open callback for the codec for when FMOD tries to open a sound using this codec. */</span>
<a name="l00054"></a>00054     FMOD_CODEC_CLOSECALLBACK        close;           <span class="comment">/* [in] Close callback for the codec for when FMOD tries to close a sound using this codec.  */</span>
<a name="l00055"></a>00055     FMOD_CODEC_READCALLBACK         read;            <span class="comment">/* [in] Read callback for the codec for when FMOD tries to read some data from the file to the destination format (specified in the open callback). */</span>
<a name="l00056"></a>00056     FMOD_CODEC_GETLENGTHCALLBACK    getlength;       <span class="comment">/* [in] Callback to return the length of the song in whatever format required when Sound::getLength is called. */</span>
<a name="l00057"></a>00057     FMOD_CODEC_SETPOSITIONCALLBACK  setposition;     <span class="comment">/* [in] Seek callback for the codec for when FMOD tries to seek within the file with Channel::setPosition. */</span>
<a name="l00058"></a>00058     FMOD_CODEC_GETPOSITIONCALLBACK  getposition;     <span class="comment">/* [in] Tell callback for the codec for when FMOD tries to get the current position within the with Channel::getPosition. */</span>
<a name="l00059"></a>00059     FMOD_CODEC_SOUNDCREATECALLBACK  soundcreate;     <span class="comment">/* [in] Sound creation callback for the codec when FMOD finishes creating the sound.  (So the codec can set more parameters for the related created sound, ie loop points/mode or 3D attributes etc). */</span>
<a name="l00060"></a>00060     FMOD_CODEC_GETWAVEFORMAT        getwaveformat;   <span class="comment">/* [in] Callback to tell FMOD about the waveformat of a particular subsound.  This is to save memory, rather than saving 1000 FMOD_CODEC_WAVEFORMAT structures in the codec, the codec might have a more optimal way of storing this information. */</span>
<a name="l00061"></a>00061 } <a class="code" href="structFMOD__CODEC__DESCRIPTION.html">FMOD_CODEC_DESCRIPTION</a>;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">/*</span>
<a name="l00065"></a>00065 <span class="comment">[STRUCTURE] </span>
<a name="l00066"></a>00066 <span class="comment">[</span>
<a name="l00067"></a>00067 <span class="comment">    [DESCRIPTION]</span>
<a name="l00068"></a>00068 <span class="comment">    Set these values marked &#39;in&#39; to tell fmod what sort of sound to create.&lt;br&gt;</span>
<a name="l00069"></a>00069 <span class="comment">    The format, channels and frequency tell FMOD what sort of hardware buffer to create when you initialize your code.  So if you wrote an MP3 codec that decoded to stereo 16bit integer PCM, you would specify FMOD_SOUND_FORMAT_PCM16, and channels would be equal to 2.&lt;br&gt;</span>
<a name="l00070"></a>00070 <span class="comment">    Members marked as &#39;out&#39; are set by fmod.  Do not modify these.  Simply specify 0 for these values when declaring the structure, FMOD will fill in the values for you after creation with the correct function pointers.&lt;br&gt;</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    [REMARKS]</span>
<a name="l00073"></a>00073 <span class="comment">    Members marked with [in] mean the variable can be written to.  The user can set the value.&lt;br&gt;</span>
<a name="l00074"></a>00074 <span class="comment">    Members marked with [out] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.&lt;br&gt;</span>
<a name="l00075"></a>00075 <span class="comment">    &lt;br&gt;</span>
<a name="l00076"></a>00076 <span class="comment">    An FMOD file might be from disk, memory or network, however the file may be opened by the user.&lt;br&gt;</span>
<a name="l00077"></a>00077 <span class="comment">    &lt;br&gt;</span>
<a name="l00078"></a>00078 <span class="comment">    &#39;numsubsounds&#39; should be 0 if the file is a normal single sound stream or sound.  Examples of this would be .WAV, .WMA, .MP3, .AIFF.&lt;br&gt;</span>
<a name="l00079"></a>00079 <span class="comment">    &#39;numsubsounds&#39; should be 1+ if the file is a container format, and does not contain wav data itself.  Examples of these types would be CDDA (multiple CD tracks), FSB (contains multiple sounds), MIDI/MOD/S3M/XM/IT (contain instruments).&lt;br&gt;</span>
<a name="l00080"></a>00080 <span class="comment">    The arrays of format, channel, frequency, length and blockalign should point to arrays of information based on how many subsounds are in the format.  If the number of subsounds is 0 then it should point to 1 of each attribute, the same as if the number of subsounds was 1.  If subsounds was 100 for example, each pointer should point to an array of 100 of each attribute.&lt;br&gt;</span>
<a name="l00081"></a>00081 <span class="comment">    When a sound has 1 or more subsounds, you must play the individual sounds specified by first obtaining the subsound with Sound::getSubSound.</span>
<a name="l00082"></a>00082 <span class="comment">    </span>
<a name="l00083"></a>00083 <span class="comment">    [PLATFORMS]</span>
<a name="l00084"></a>00084 <span class="comment">    Win32, Win64, Linux, Linux64, Macintosh, Xbox360, PlayStation 2, PlayStation Portable, PlayStation 3, Wii, Solaris, iPhone</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">    [SEE_ALSO]</span>
<a name="l00087"></a>00087 <span class="comment">    FMOD_SOUND_FORMAT</span>
<a name="l00088"></a>00088 <span class="comment">    FMOD_FILE_READCALLBACK      </span>
<a name="l00089"></a>00089 <span class="comment">    FMOD_FILE_SEEKCALLBACK      </span>
<a name="l00090"></a>00090 <span class="comment">    FMOD_CODEC_METADATACALLBACK</span>
<a name="l00091"></a>00091 <span class="comment">    Sound::getSubSound</span>
<a name="l00092"></a>00092 <span class="comment">    Sound::getNumSubSounds</span>
<a name="l00093"></a>00093 <span class="comment">]</span>
<a name="l00094"></a>00094 <span class="comment">*/</span>
<a name="l00095"></a><a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">00095</a> <span class="keyword">struct </span><a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">FMOD_CODEC_WAVEFORMAT</a>
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097     <span class="keywordtype">char</span>               name[256];     <span class="comment">/* [in] Name of sound.*/</span>
<a name="l00098"></a>00098     FMOD_SOUND_FORMAT  format;        <span class="comment">/* [in] Format for (decompressed) codec output, ie FMOD_SOUND_FORMAT_PCM8, FMOD_SOUND_FORMAT_PCM16.*/</span>
<a name="l00099"></a>00099     <span class="keywordtype">int</span>                channels;      <span class="comment">/* [in] Number of channels used by codec, ie mono = 1, stereo = 2. */</span>
<a name="l00100"></a>00100     <span class="keywordtype">int</span>                frequency;     <span class="comment">/* [in] Default frequency in hz of the codec, ie 44100. */</span>
<a name="l00101"></a>00101     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       lengthbytes;   <span class="comment">/* [in] Length in bytes of the source data. */</span>
<a name="l00102"></a>00102     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       lengthpcm;     <span class="comment">/* [in] Length in decompressed, PCM samples of the file, ie length in seconds * frequency.  Used for Sound::getLength and for memory allocation of static decompressed sample data. */</span>
<a name="l00103"></a>00103     <span class="keywordtype">int</span>                blockalign;    <span class="comment">/* [in] Blockalign in decompressed, PCM samples of the optimal decode chunk size for this format.  The codec read callback will be called in multiples of this value. */</span>
<a name="l00104"></a>00104     <span class="keywordtype">int</span>                loopstart;     <span class="comment">/* [in] Loopstart in decompressed, PCM samples of file. */</span>
<a name="l00105"></a>00105     <span class="keywordtype">int</span>                loopend;       <span class="comment">/* [in] Loopend in decompressed, PCM samples of file. */</span>
<a name="l00106"></a>00106     FMOD_MODE          mode;          <span class="comment">/* [in] Mode to determine whether the sound should by default load as looping, non looping, 2d or 3d. */</span>
<a name="l00107"></a>00107     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       channelmask;   <span class="comment">/* [in] Microsoft speaker channel mask, as defined for WAVEFORMATEXTENSIBLE and is found in ksmedia.h.  Leave at 0 to play in natural speaker order. */</span>
<a name="l00108"></a>00108 };
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/*</span>
<a name="l00112"></a>00112 <span class="comment">[STRUCTURE] </span>
<a name="l00113"></a>00113 <span class="comment">[</span>
<a name="l00114"></a>00114 <span class="comment">    [DESCRIPTION]</span>
<a name="l00115"></a>00115 <span class="comment">    Codec plugin structure that is passed into each callback.&lt;br&gt;</span>
<a name="l00116"></a>00116 <span class="comment">    &lt;br&gt;</span>
<a name="l00117"></a>00117 <span class="comment">    Set these numsubsounds and waveformat members when called in FMOD_CODEC_OPENCALLBACK to tell fmod what sort of sound to create.&lt;br&gt;</span>
<a name="l00118"></a>00118 <span class="comment">    &lt;br&gt;</span>
<a name="l00119"></a>00119 <span class="comment">    The format, channels and frequency tell FMOD what sort of hardware buffer to create when you initialize your code.  So if you wrote an MP3 codec that decoded to stereo 16bit integer PCM, you would specify FMOD_SOUND_FORMAT_PCM16, and channels would be equal to 2.&lt;br&gt;</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">    [REMARKS]</span>
<a name="l00122"></a>00122 <span class="comment">    Members marked with [in] mean the variable can be written to.  The user can set the value.&lt;br&gt;</span>
<a name="l00123"></a>00123 <span class="comment">    Members marked with [out] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.&lt;br&gt;</span>
<a name="l00124"></a>00124 <span class="comment">    &lt;br&gt;</span>
<a name="l00125"></a>00125 <span class="comment">    An FMOD file might be from disk, memory or internet, however the file may be opened by the user.&lt;br&gt;</span>
<a name="l00126"></a>00126 <span class="comment">    &lt;br&gt;</span>
<a name="l00127"></a>00127 <span class="comment">    &#39;numsubsounds&#39; should be 0 if the file is a normal single sound stream or sound.  Examples of this would be .WAV, .WMA, .MP3, .AIFF.&lt;br&gt;</span>
<a name="l00128"></a>00128 <span class="comment">    &#39;numsubsounds&#39; should be 1+ if the file is a container format, and does not contain wav data itself.  Examples of these types would be CDDA (multiple CD tracks), FSB (contains multiple sounds), DLS (contain instruments).&lt;br&gt;</span>
<a name="l00129"></a>00129 <span class="comment">    The arrays of format, channel, frequency, length and blockalign should point to arrays of information based on how many subsounds are in the format.  If the number of subsounds is 0 then it should point to 1 of each attribute, the same as if the number of subsounds was 1.  If subsounds was 100 for example, each pointer should point to an array of 100 of each attribute.&lt;br&gt;</span>
<a name="l00130"></a>00130 <span class="comment">    When a sound has 1 or more subsounds, you must play the individual sounds specified by first obtaining the subsound with Sound::getSubSound.</span>
<a name="l00131"></a>00131 <span class="comment">    </span>
<a name="l00132"></a>00132 <span class="comment">    [PLATFORMS]</span>
<a name="l00133"></a>00133 <span class="comment">    Win32, Win64, Linux, Linux64, Macintosh, Xbox360, PlayStation 2, PlayStation Portable, PlayStation 3, Wii, Solaris, iPhone</span>
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">    [SEE_ALSO]</span>
<a name="l00136"></a>00136 <span class="comment">    FMOD_SOUND_FORMAT</span>
<a name="l00137"></a>00137 <span class="comment">    FMOD_FILE_READCALLBACK      </span>
<a name="l00138"></a>00138 <span class="comment">    FMOD_FILE_SEEKCALLBACK      </span>
<a name="l00139"></a>00139 <span class="comment">    FMOD_CODEC_METADATACALLBACK</span>
<a name="l00140"></a>00140 <span class="comment">    Sound::getSubSound</span>
<a name="l00141"></a>00141 <span class="comment">    Sound::getNumSubSounds</span>
<a name="l00142"></a>00142 <span class="comment">]</span>
<a name="l00143"></a>00143 <span class="comment">*/</span>
<a name="l00144"></a><a class="code" href="structFMOD__CODEC__STATE.html">00144</a> <span class="keyword">struct </span><a class="code" href="structFMOD__CODEC__STATE.html">FMOD_CODEC_STATE</a>
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146     <span class="keywordtype">int</span>                         numsubsounds;  <span class="comment">/* [in] Number of &#39;subsounds&#39; in this sound.  Anything other than 0 makes it a &#39;container&#39; format (ie CDDA/DLS/FSB etc which contain 1 or more su bsounds).  For most normal, single sound codec such as WAV/AIFF/MP3, this should be 0 as they are not a container for subsounds, they are the sound by itself. */</span>
<a name="l00147"></a>00147     <a class="code" href="structFMOD__CODEC__WAVEFORMAT.html">FMOD_CODEC_WAVEFORMAT</a>      *waveformat;    <span class="comment">/* [in] Pointer to an array of format structures containing information about each sample.  Can be 0 or NULL if FMOD_CODEC_GETWAVEFORMAT callback is preferred.  The number of entries here must equal the number of subsounds defined in the subsound parameter. If numsubsounds = 0 then there should be 1 instance of this structure. */</span>
<a name="l00148"></a>00148     <span class="keywordtype">void</span>                       *plugindata;    <span class="comment">/* [in] Plugin writer created data the codec author wants to attach to this object. */</span>
<a name="l00149"></a>00149                                                
<a name="l00150"></a>00150     <span class="keywordtype">void</span>                       *filehandle;    <span class="comment">/* [out] This will return an internal FMOD file handle to use with the callbacks provided.  */</span>
<a name="l00151"></a>00151     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                filesize;      <span class="comment">/* [out] This will contain the size of the file in bytes. */</span>
<a name="l00152"></a>00152     FMOD_FILE_READCALLBACK      fileread;      <span class="comment">/* [out] This will return a callable FMOD file function to use from codec. */</span>
<a name="l00153"></a>00153     FMOD_FILE_SEEKCALLBACK      fileseek;      <span class="comment">/* [out] This will return a callable FMOD file function to use from codec.  */</span>
<a name="l00154"></a>00154     FMOD_CODEC_METADATACALLBACK metadata;      <span class="comment">/* [out] This will return a callable FMOD metadata function to use from codec.  */</span>
<a name="l00155"></a>00155 };
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="preprocessor">#endif</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00159"></a>00159 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 13 19:11:32 2010 for Live-Jamming by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
